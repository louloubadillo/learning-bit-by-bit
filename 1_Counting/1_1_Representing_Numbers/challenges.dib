#!csharp

//Packages
#r "nuget: Interactive.Journey"
#r "nuget: Interactive.Extension.ImageSharp"
//Libraries
using Microsoft.DotNet.Interactive.Journey;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.CSharp;
using Microsoft.DotNet.Interactive.Events;
using SixLabors.ImageSharp;
using System.IO;

#!markdown

# [Challenge] Individual Marks

#!csharp

//Reset the challenge before starting a new one
Lesson.ResetChallenge();

#!csharp

Func<char[], int> countIndividualMarks = charArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Rule: 1.1.1. Individual Marks", context =>
{
    
    // for(int i = 0; i < 4; i++){
    Random rnd = new Random();
    int n = rnd.Next();

    string str = "";
    for(int j = 0; j < n; j++) str+= '.';

    if(countIndividualMarks(str.ToCharArray()) != str.Length){
        context.Fail("Counting function is incorrect, expected " + n);
        // break;
    }
    // }
    else context.Pass("Counting function is correct");
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        context.SetMessage("Please wait! We are checking your submission");
        int numPassed = context.RuleEvaluations.Count(e => e.Passed);
        int total = context.RuleEvaluations.Count();
        if(numPassed != total){
            context.SetMessage("Congratulations! Challenge completed");
            await context.StartNextChallengeAsync();
        } else {
            context.SetMessage("Challenge 1.1.1. Is not complete");
        }
    });

#!markdown

[Question] 
<h2>1.1.1. Individual marks </h2>

An immediate solution to the counting problem might be grabbing a piece of paper and marking a dot per person. The more items there are in the set, the more dots there would be on the paper.

<mark>_Write a program that receives a string dots and counts them._</mark>

#!csharp

countIndividualMarks = charArray =>
{
    // Write your answer here
    throw new NotImplementedException();
};

#!markdown

# [Challenge] Grouping Symbols

#!csharp

//Reset the challenge before starting a new one
Lesson.ResetChallenge();

#!csharp

Func<char[], int> countManyMarks = charArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Rule: 1.1.2. Grouping symbols", context =>
{
    char[] symbols = {'*', 'o', '.'};
    
    Random rnd = new Random();
    int n = rnd.Next(10);

    string str = "";
    int correctAns = 0;
    for(int i = 0; i < n; i++){
        char c = symbols[rnd.Next(3)];
        str+=c;
        if(c == '*') correctAns += 25;
        if(c == 'o') correctAns += 5;
        if(c == '.') correctAns += 1;
    }
    if (correctAns == countManyMarks(str.ToCharArray()))
    {
        context.Pass("Counting function is correct");
    }
    else
    {
        context.Fail("Counting function is incorrect");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        context.SetMessage("Please wait! We are checking your submission");
        int numPassed = context.RuleEvaluations.Count(e => e.Passed);
        int total = context.RuleEvaluations.Count();
        if(numPassed != total){
            context.SetMessage("Congratulations! Challenge completed");
            await context.StartNextChallengeAsync();
        } else {
            context.SetMessage("Challenge 1.1.2. Is not complete");
        }
    });

#!markdown

[Question]
<h2>1.1.2. Grouping symbols</h2>

It might seem obvious how the above process might become troublesome for very big numbers. You would have to manually re-count the dots, and you will probably run out of space pretty quickly!

So now you think of a clever way to extend this idea and you realize that the whole point of using dots in the first place was to talk about quantities in a symbolic manner. Thus, to save some space, you start **grouping quantitites** using different symbols that represent different quantities, such as:

| Symbol         | Relative Value | Value in units |
|----------------|----------------|----------------|
| .              | .              | 1 unit         |
| o              | .....          | 5 units        |
| *              | ooooo          | 25 units       |


<mark>_Using the table above, write a program that receives an array of characters and returns the represented number._</mark>

#!csharp

countManyMarks = charArray =>
{
    // Answer here
    // Return the represented number if
    // . = 1
    // o = 5
    // * = 25
    throw new NotImplementedException(); 
};

#!markdown

# [Challenge] Grouping + Position

#!csharp

//Reset the challenge before starting a new one
Lesson.ResetChallenge();

#!csharp

Func<char[,], int> countGroupPosition = rectanglesArray => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Rule: 1.1.3. Grouping with position", context =>
{
    Random rnd = new Random();
    int numberOfRectangles = rnd.Next(7);
    char[,] arr = new char[numberOfRectangles,6];
    for(int i = 0; i < numberOfRectangles; i++){
        int numberOfElements = rnd.Next(6);
        for(int j = 0; j < numberOfElements; j++){
            arr[i, j] = '.';
        }
    }

    int representedNumber = 0;
    for(int i = arr.Length; i > 0; i--){
        int rectangleValue = 0;
        for(int j = 0; j < 6; j++){
            if(arr[i,j] == '.') rectangleValue++;
        }
        representedNumber += (int) Math.Pow(rectangleValue, (arr.Length - i));
    }
    if(representedNumber == countGroupPosition(arr)){
        context.Pass("Counting function is correct");
    } else {
        context.Fail("Counting function is incorrect");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
{
    context.SetMessage("Please wait! We are checking your submission");
    int numPassed = context.RuleEvaluations.Count(e => e.Passed);
    int total = context.RuleEvaluations.Count();
    if(numPassed != total){
        context.SetMessage("Congratulations! Challenge completed");
        await context.StartNextChallengeAsync();
    } else {
        context.SetMessage("Challenge 1.1.3. is not complete");
    }
});

#!markdown

[Question]
<h2> 1.1.3. Better grouping with position </h2>

The grouping solution works great. However you quickly realize that: 
* You would need an infinite amount of symbols to efficiently represent any arbitrary number
* There is no rule for the order of the symbols, which makes the reading confusing

You come up with a great idea:
1. You draw rectangles that can represent up to a maximum number
2. When a rectangle is fill you add another one to its left
3. Hence each unit on a rectangle equals the maximum value of the rectangle to its right

! Add manim animation here

<mark>_Assuming each rectangle can represent a quantity up to 5, write a program that receives a 2D array and returns the represented number according to the rules above._</mark>

#!csharp

countGroupPosition = arr =>
{
    // Answer here
    // Return represented number. E.g.,
    //   [['.'], ['.', '.', '.'], ['.', '.']] = (1 * n^2) + (3 * n^1) + (2 * n^0)
    // In this case, assume n = 5
    throw new NotImplementedException(); 
};

#!markdown

# [Challenge] Positional Systems

#!markdown

[Question]
<h2>1.1.4. Positional systems</h2>

What if instead of using boxes of dots we assign each value inside the rectangle its own symbol? We would have a limited amount of symbols and would rely on position to give them meaning. You might be thinking "wait, isn't that how we count?", and you would be right: **that is how the decimal system works.**

In the decimal systems we use 10 different symbols, and each position represents a different power of 10. Using this, we can succesfully represent huge quantities without compromising on space or understanding. 

It is believed that 10 is used globally as the _default_ base bacause most of us have 10 fingers. However we can take this idea to its simplest: using only 2 symbols. **This system is called BINARY, and is at the heart of Computer Science**

<mark>_Write a program that receives a string of ones and zeros and returns the represented number._</mark>

#!csharp

//Reset the challenge before starting a new one
Lesson.ResetChallenge();

#!csharp

Func<string, int> countBinary = binaryString => 0;

#!csharp

Lesson.CurrentChallenge.AddRule("Rule: 1.1.4. Positional systems", context =>
{
    Random rnd = new Random();
    int number = rnd.Next(999);
    string binaryString = Convert.ToString(number, 2);

    if(number == countBinary(binaryString)){
        context.Pass("Counting function is correct");
    } else {
        context.Fail("Counting function is incorrect");
    }
});

#!csharp

Lesson.CurrentChallenge.OnCodeSubmitted(async context =>
    {
        context.SetMessage("Please wait! We are checking your submission");
        int numPassed = context.RuleEvaluations.Count(e => e.Passed);
        int total = context.RuleEvaluations.Count();
        if(numPassed != total){
            context.SetMessage("Congratulations! Challenge completed");
            await context.StartNextChallengeAsync();
        } else {
            context.SetMessage("Challenge 1.1.4. is not complete");
        }
    });
